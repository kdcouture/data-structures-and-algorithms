/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package LinkedList;

class LinkedList<T> {
    // Data
    LinkedListNode head;
//    int size;

    // Constructor
    public LinkedList() {
        this.head = null;
//        this.size = 0;
    }

    // Methods

    public void append(T toAppend) {
        LinkedListNode cur = this.head;
        if(cur == null) {
            this.insert(toAppend);
            return;
        }
        while(cur.next != null) {
            cur = cur.next;
        }
//        this.size++;
        cur.next = new LinkedListNode(toAppend, null);
    }

    public void insertAfter(T toFind, T value) throws Exception {
        LinkedListNode cur;
        cur = this.head;
        while (cur != null) {
            if(cur.value.equals(toFind)) {
                // create and attach cur.next
                LinkedListNode newNode = new LinkedListNode(value, cur.next);
                // attach newNode after current.
                cur.next = newNode;
//                this.size++;
                return;
            }
            else {
                cur = cur.next;
            }
        }
        throw new Exception("Value not found");
    }

    public void insertBefore(T toFind, T value) throws Exception {
        LinkedListNode pre, cur;
        if(this.head.value.equals(toFind)){
            this.insert(value);
            return;
        }
        else {
            pre = this.head;
            cur = this.head;
            while (cur != null) {
                if(cur.value.equals(toFind)) {
                    // Create and set newNode's next to current
                    LinkedListNode newNode = new LinkedListNode(value, cur);
                    // set old prior to point to new node
                    pre.next = newNode;
//                    this.size++;
                    return;
                }
                else {
                    pre = cur;
                    cur = cur.next;
                }
            }
        }
        throw new Exception("Value not found");
    }

    public void insert(T value) {
        this.head = new LinkedListNode(value, this.head);
//        this.size++;
    }

    public boolean includes(T target) {
        LinkedListNode cur = this.head;
        while(cur != null) {
            if(cur.value.equals(target)) {
                return true;
            }
            cur = cur.next;
        }
        return false;
    }

    public T kthFromEnd(int k) throws Exception {
        int length = this.length(this.head) - 1;
        if(k > length) {
            throw new Exception("k is invalid.");
        }
        LinkedListNode<T> cur = this.head;
        for(int i = 1; i < (length - k); i++) {
            cur = cur.next;
        }
        return cur.value;
    }

    public int length(LinkedListNode current) {
        // Base case current = null
        if(current == null) {
            return 1;
        }
        // Recursively crawl through list.
        else {
            return this.length(current.next)+1;
        }
    }

    public static LinkedList merge(LinkedList l1, LinkedList l2) {
        if(l1.head == null) {
            return l2;
        }
        else if (l2.head == null) {
            return l1;
        }
        LinkedListNode l1Cur =l1.head.next; // Tracks l1
        LinkedListNode l2Cur = l2.head; // Tracks l2
        LinkedList<LinkedListNode> mergedList = new LinkedList<LinkedListNode>();
        mergedList.head = l1.head;
        LinkedListNode mCur = mergedList.head; // Tracks merged list
        while(l1Cur != null && l2Cur != null){
            // Link L2 Node
            mCur.next = l2Cur;
            // Move merged tracker
            mCur= mCur.next;
            // Move l2 tracker
            l2Cur = l2Cur.next;

            // Link l1 Node
            mCur.next = l1Cur;
            // Move l1 tacker forward
            l1Cur = l1Cur.next;
            // Move merged tracker
            mCur = mCur.next;
        }
        while(l1Cur != null) {
            // Link l1 Node
            mCur.next = l1Cur;
            // Move l1 tacker forward
            l1Cur = l1Cur.next;
            // Move merged tracker
            mCur = mCur.next;
        }
        while(l2Cur != null) {
            // Link l2 Node
            mCur.next = l2Cur;
            // Move l2 tacker forward
            l2Cur = l2Cur.next;
            // Move merged tracker
            mCur = mCur.next;
        }
        return mergedList;
    }

    public String toString() {
        String strBuild = "";
        if(this.head == null) {
            return "Empty Linked List";
        }
        LinkedListNode cur = this.head;
        while(cur.next != null) {
            strBuild += (cur.value.toString() + " ");
            cur = cur.next;
        }
        strBuild += cur.value.toString();
        return strBuild;
    }

}

class LinkedListNode<T>{
    // Data
    T value;
    LinkedListNode next;

    // Constructors
    public LinkedListNode(){
        this.value = null;
        this.next = null;
    }
    public LinkedListNode(T value, LinkedListNode next) {
        this.value = value;
        this.next = next;
    }

    // Functions
    public boolean hasNext(){
        if(this.next != null) {
            return true;
        }
        return false;
    }
    // For Testing
    public boolean compareNodeValues(LinkedListNode compTo) {
        if(this.value.equals(compTo.value)) {
            return true;
        }
        return false;
    }
    public boolean compareValue(T compTo) {
        if(this.value == compTo) {
            return true;
        }
        return false;
    }

}
