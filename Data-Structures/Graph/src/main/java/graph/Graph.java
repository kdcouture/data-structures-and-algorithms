/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package graph;

import java.util.*;

public class Graph {
    private HashMap<String, ArrayList<GraphEdge>> vertices;

    public Graph() {
        vertices = new HashMap<String, ArrayList<GraphEdge>>();
    }

    public ArrayList<String> depthFirst(String start) {
        // Holds the array list to return.
        ArrayList<String> toRet = new ArrayList<String>();
        // Holds nodes we have visited.
        Stack<String> toVisit = new Stack<String>();
        // Temp to hold each nodes adj list.
        ArrayList<GraphEdge> adjListTemp;
        // Temp to hold the current key.
        String currentKey = "";
        // temp to hold the current adj key.
        String adjKey = "";

        // Verify graph contains the vertex.
        if(this.vertices.containsKey(start)) {
            // Init loop start.
            toVisit.add(start);
            while(!toVisit.isEmpty()){
                // Pop element from stack.
                currentKey = toVisit.pop();
                // Duplicate return key check.
                if(!toRet.contains(currentKey)){
                    // Add current to the return list.
                    toRet.add(currentKey);
                }
                // Add current node's adj nodes.
                adjListTemp = this.vertices.get(currentKey);
                // Check all adj nodes.
                for(int i = 0; i < adjListTemp.size(); i++) {
                    adjKey = adjListTemp.get(i).getDestKey();
                    // Verify it has not been seen yet.
                    if(!toRet.contains(adjKey)){
                        toVisit.push(adjKey);
                    }
                }
            }
        }
        return toRet;
    }

    public ArrayList<String> breadthFirst(String start) {
        // Holds the array list to return.
        ArrayList<String> toRet = new ArrayList<String>();
        // Holds nodes we have visited.
        Queue<String> toVisit = new LinkedList<String>();
        // Temp to hold each nodes adj list.
        ArrayList<GraphEdge> adjListTemp;
        // Temp to hold the current key.
        String currentKey = "";
        // temp to hold the current adj key.
        String adjKey = "";

        // Verify graph contains the vertex.
        if(this.vertices.containsKey(start)) {
            // Init loop start.
            toVisit.add(start);
            while(!toVisit.isEmpty()){
                // Pop element from stack.
                currentKey = toVisit.remove();
                // Duplicate return key check.
                if(!toRet.contains(currentKey)){
                    // Add current to the return list.
                    toRet.add(currentKey);
                }
                // Add current node's adj nodes.
                adjListTemp = this.vertices.get(currentKey);
                // Check all adj nodes.
                for(int i = 0; i < adjListTemp.size(); i++) {
                    adjKey = adjListTemp.get(i).getDestKey();
                    // Verify it has not been seen yet.
                    if(!toRet.contains(adjKey)){
                        toVisit.add(adjKey);
                    }
                }
            }
        }
        return toRet;
    }

    public String getNodes() {
        return vertices.keySet().toString();
    }

    public ArrayList<GraphEdge> getNeighbors(String key) {
        if(vertices.containsKey(key)) {
            return vertices.get(key);
        }
        else {
            return null;
        }
    }

    public void addNode(String key) {
        vertices.putIfAbsent(key, new ArrayList<GraphEdge>());
    }

    public void addEdge(String key, String dest, int weight) {
        // Verify both source and dest keys exist.
        if(vertices.containsKey(key) && vertices.containsKey(dest)){
            ArrayList<GraphEdge> adjList = vertices.get(key);
            // Create new edge object.
            GraphEdge newEdge = new GraphEdge(dest, weight);
            // Lower flag.
            boolean edgeExists = false;
            // Check if an edge already exists between the two nodes.
            for(int i = 0; i < adjList.size(); i++) {
                // If yes, do not add edge.
                if(adjList.get(i).getDestKey() == newEdge.getDestKey()){
                    edgeExists = true;
                    break;
                }
            }
            // If no edge exists, add the new edge obj.
            if(!edgeExists){
                adjList.add(newEdge);
                vertices.replace(key, adjList);
            }
            else {
                System.out.println("Edge already exists.");
            }
        }
    }

    public int size() {
        return vertices.size();
    }

}
