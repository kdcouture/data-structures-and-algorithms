/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tree;

import java.util.ArrayList;

public class BST<T> {
    TreeNode root;

    public BST() {
        this.root = null;
    }

    // Wraps Recursive printouts.
    public ArrayList<T> preOrder(){
        ArrayList<T> build = new ArrayList<>();
        buildPreOrder(this.root, build);
        return build;
    }

    public void buildPreOrder(TreeNode node, ArrayList build) {
        if(node != null) {
            build.add(node.data);
            buildPreOrder(node.left, build);
            buildPreOrder(node.right, build);
        }
    }

    // Wraps Recursive printouts.
    public ArrayList<T> inOrder(){
        ArrayList<T> build = new ArrayList<>();
        buildInOrder(this.root, build);
        return build;
    }

    public void buildInOrder(TreeNode node, ArrayList build) {
        if(node != null) {
            buildInOrder(node.left, build);
            build.add(node.data);
            buildInOrder(node.right, build);
        }
    }

    // Wraps Recursive printouts.
    public ArrayList<T> postOrder(){
        ArrayList<T> build = new ArrayList<>();
        buildPostOrder(this.root, build);
        return build;
    }

    public void buildPostOrder(TreeNode node, ArrayList build) {
        if(node != null) {
            buildPostOrder(node.left, build);
            buildPostOrder(node.right, build);
            build.add(node.data);
        }
    }

    public boolean contains(T data) {
        boolean isFound = false;
        TreeNode searchFor = new TreeNode(data);
        TreeNode itr = this.root;
        while(itr != null) {
            // Check current node data
            if(itr.compare(searchFor) == 0) {
                isFound = true;
                break;
            }
            // Look Left
            if(itr.compare(searchFor) >= -1) {
                itr = itr.left;
            }
            // Look Right
            else {
                itr = itr.right;
            }
        }

        return isFound;
    }

    public void add(T data) {
        TreeNode newTreeNode = new TreeNode(data);
        if(this.root == null) {
            this.root = newTreeNode;
        }
        else {
            TreeNode itr = this.root;
            Boolean isPlaced = false;
            while (!isPlaced) {
                // Look Left
                if(itr.compare(newTreeNode) >= 1) {
                    if(itr.left == null) {
                        itr.left = newTreeNode;
                        isPlaced = true;
                    }
                    // Not place, keep moving
                    itr = itr.left;
                }
                // Look Right
                else {
                    if (itr.right == null) {
                        itr.right = newTreeNode;
                        isPlaced = true;
                    }
                    // Not place, keep moving
                    itr = itr.right;
                }
            }
        }
    }
}

class TreeNode<T> {
    TreeNode left;
    TreeNode right;
    T data;

    public TreeNode(T data) {
        this.data = data;
        this.left = null;
        this. right = null;
    }

    public int compare(TreeNode toCheck) {
        return this.toString().compareTo(toCheck.toString());
    }

    public String toString() {
        return this.data.toString();
    }
}
